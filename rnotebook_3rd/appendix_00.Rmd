---
title: "tidyverse"
author: "한상곤(sangkon@pusan.ac.kr)"
date: "2023.06.13(화)"
output:
  pdf_document:
    extra_dependencies: kotex
    fig_height: 6
    fig_width: 10
    toc: yes
    fig_caption: yes
    number_sections: yes
  word_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=T, fig.align = "center", message=F, warning=F, fig.height = 8, cache=T, dpi = 300, dev = "png")
```

# tidyverse

`tidyverse`는 R에서 데이터분석에 필수적으로 사용되는 패키지입니다. RStudio의 해들리 위캠(Hadley Wickham) 박사 팀이 주도적으로 이끌고 있으며 대표적으로 `ggplot2`, `dplyr`, `tidyr`, `readr`, `purrr`, `tibble`, `stringr`, `forcats` 등이 포함되어 있습니다. 단일 패키지가 아니라 통합 패키지 형태로 되어 있이서, 한번에 설치가 가능합니다. 

- ggplot은 데이터를 시각화하는데 사용
- dplyr는 `data.frame` 기반의 데이터 처리에 사용
- tidyr는 조건에 따른 데이터 처리에 사용
- readr는 tableau 데이터를 읽는데 사용
- purrr는 데이터를 일괄처리하는데 사용
- tibble은 `data.frame`과 유사한 자료구조를 제공
- stringr은 문자열을 다루기 위해서 사용
- forcats은 범주형 자료를 다룰 때 사용

## tidyverse 설치

`install.packages`를 사용해서 설치하면 관련된 모든 패키지가 설치됩니다.

```R
if(!require(tidyverse)) install.packages("tidyverse")

── Attaching core tidyverse packages ───────── tidyverse 2.0.0 ──
✔ dplyr     1.1.2     ✔ readr     2.1.4
✔ forcats   1.0.0     ✔ stringr   1.5.0
✔ ggplot2   3.4.2     ✔ tibble    3.2.1
✔ lubridate 1.9.2     ✔ tidyr     1.3.0
✔ purrr     1.0.1     
── Conflicts ─────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package to force all conflicts to become errors
```

```{R}
library(tidyverse)
```

## dplyr

데이터를 정리하기 위해서 dplyr에서 제공하는 변환은 크게 5가지입니다.

- 행
  - 선택
    - filter, 데이터에서 특정 열의 값이 조건에 맞는 행을 선택
    - slice, 데이터에서 특정 위치의 행을 선택
  - 정렬
    - arrange, 특정 열의 값을 기준으로 데이터의 행을 정렬
- 열
  - 선택
    - select, 열의 이름, 위치, 데이터 형식 등으로 열을 선택
  - 추가
    - mutate, 기존 열을 사용하여 새로운 열을 데이터에 추가
- 요약
  - summarize(), 데이터 전체 또는 특정 열을 하나의 통계량으로 요약
  - group_by(): 데이터 요약에만 사용되는 것은 아니나, 그룹별로 데이터를 통계 요약할 때 자주 사용

`mpg` 데이터를 사용해서 예제를 진행하겠습니다. mpg는 1999년과 2008년에 미국 EPA에서 조사하여 발표한 자동차 주요 모델별 연비 데이터입니다. mpg 데이터는 234 개의 행이 있으며, 각 행은 다음과 같은 변수로 구성되어 있습니다.

- manufacturer: 자동차 제조사
- model: 자동차 모델명
- displ: 자동차 배기량
- year: 제조년도
- cyl: 엔진 실린더 수
- trans: 자동차 트랜스미션 종류
- drv: 자동차 구동 방식. f=전륜구동, r=후륜구동, 4=사륜구동
- cty: 도심 연비 (마일/갤론)
- hwy: 고속도로 연비 (마일/갤론)
- fl: 연료 종류
- class: 자동차 분류

```{R}
data(mpg)
mpg
```

### filter, 데이터에서 특정 열의 값이 조건에 맞는 행을 선택할 수 있습니다.

```{R}
filter(mpg, manufacturer=="hyundai")
filter(mpg, cty > 28)
filter(mpg, cty * 2 > 60) # 연산 후 결과를 기반으로 비교 가능
filter(mpg, manufacturer=="hyundai", cty >= 20) # 여러 조건을 한번에 선택 가능
filter(mpg, model=="sonata" | cty >= 28) # 논리 연산자를 사용가능
filter(mpg, model=="sonata" | cty >= 28, year==2008)
```

`%in%` 연산자를 사용하면 다양한 형태의 조건식을 활용할 수 있습니다.

```{R}
filter(mpg, year==2008, hwy >= 28, model %in% c("sonata","corolla","jetta"))
```

### slice, 데이터에서 특정 위치의 행을 선택

slice를 사용하면 특정 위치의 행을 선택할 수 있습니다.

```{R}
hyundai_2008 <- filter(mpg, manufacturer == "hyundai", year == 2008)
slice(hyundai_2008, 1) # 1 행 선택
slice(hyundai_2008, 1:3) # 1-3 행 선택
slice(hyundai_2008, 1:3, 6:7) # 1-3과 6-7 행 선택
slice(hyundai_2008, -1) # 1행 제외
slice(hyundai_2008, -1, -(4:6))  # 1 행과 4-6 행 제외
```

`slice_sample`을 사용하면 데이터에서 원하는 수 또는 비율만큼 행을 임의 추출할 수 있습니다. `slince_`로 시작하는 다양한 선택 함수를 제공합니다.

```{R}
slice_sample(hyundai_2008, n=10)
slice_sample(hyundai_2008, prop=0.8) # 데이터에서 80% 행을 추출
slice_head(mpg, n=4)  # 데이터의 처음 4 행 추출
slice_tail(mpg, prop=0.05) # 데이터의 마지막 5% 추출
slice_min(mpg, cty, n=2) # cty 열의 값이 가장 작은 2 행 추출
slice_min(mpg, cty, n=2, with_ties = F) # 동률 행을 추출하지 않는다.
```

### arrange, 특정 열의 값을 기준으로 데이터의 행을 정렬

```{R}
arrange(hyundai_2008, cyl)
arrange(hyundai_2008, cyl, cty)
arrange(hyundai_2008, model, trans)
arrange(hyundai_2008, desc(cyl))
arrange(hyundai_2008, desc(cyl), cty)
arrange(hyundai_2008, model, desc(trans))
```

### select, 열의 이름, 위치, 데이터 형식 등으로 열을 선택

```{R}
select(hyundai_2008, model, year, cty, hwy)
select(hyundai_2008, model:trans, cty:hwy)
select(hyundai_2008, -(model:trans))
select(hyundai_2008, 1:3) # 1 번부터 3번 열 선택
select(hyundai_2008, 1:3, 5) # 1 번부터 3번 열과 5 번 열 선택
select(hyundai_2008, -(4:10)) # 4 번부터 10 번 열 제외하고 선택
```

dplyr 패키지는 다양한 형태로 변수를 선택할 수 있도록 다음의 변수 이름 매칭 함수를 제공합니다. 이러한 함수는 변수의 수가 많을 때 매우 유용합니다.

- starts_with("abs"), abc로 이름이 시작하는 모든 변수
- ends_with("abs"), abc로 이름이 끝나는 모든 변수
- contains("abs"),  abc를 이름에 포함하고 있는 모든 변수
- matches("(.)\\1"), 정규 표현식을 만족하는 이름을 가진 모든 변수
- num_range("x", 1:3), "x1", "x2", "x3"이라는 이름의 변수

```{R}
select(hyundai_2008, starts_with("c"))
```

select 함수에 where 함수를 사용하면 해당 조건에 맞는 열만 매칭하여 선택할 수 있습니다. where 함수는 유일한 인수로 함수를 입력받는데, 이 함수는 논리값을 반환하는 함수여야 하며, where 함수는 각 열에 이 함수를 적용합니다. select 함수는 where의 결과가 TRUE인 열만 선택합니다.

where 함수가 주로 사용되는 곳은 데이터 형식에 따라 열을 선택할 때입니다. `is.`로 시작하는 함수들은 어떤 객체가 특정 형식인지를 테스트 합니다. 다음 예는 where 와 is.character 함수를 사용하여 문자열인 열만 선택한 것입니다.

```{R}
select(hyundai_2008, where(is.character))
select(hyundai_2008, where(function(x) is.numeric(x) && mean(x) >= 10))
select(hyundai_2008, where(~ is.numeric(.x) && mean(.x) < 10)) # purrr 형식
```

select 함수에서 변수 이름을 지정할 때, (새로운 변수 이름)=(기존 변수 이름) 형식으로 지정하면 변수의 이름을 바꿀 수 있습니다.

```{R}
select(hyundai_2008, model, city=cty, highway=hwy)
rename(hyundai_2008, city=cty, highway=hwy) # 변수 이름만 변경 가능
```

select 함수는 나열된 변수의 순서에 따라 새롭게 만들어진 데이터 프레임의 변수의 순서를 조정 가능합니다.

```{R}
select(hyundai_2008, cty, hwy)
select(hyundai_2008, hwy, cty)
select(hyundai_2008, cty, hwy, everything())
```

### mutate, 기존 열을 사용하여 새로운 열을 데이터에 추가

mutate는 기존 변수를 이용하여 새로운 변수를 만들어 데이터 프레임의 가장 마지막 열로 추가합니다.

```{R}
hyundai_2008_displ <- select(hyundai_2008, -(cyl:drv), -(fl:class))
mutate(hyundai_2008_displ, sum=cty + hwy)
mutate(hyundai_2008_displ, 
       sum=cty + hwy, 
       mean=(cty + hwy) / 2,
       ratio= cty / hwy * 100)
```

만약 새롭게 만들어진 변수만 데이터에 남기려면 mutate() 대신 transmute()를 사용합니다.

```{R}
transmute(hyundai_2008_displ, 
          sum=cty + hwy, 
          mean=(cty + hwy) / 2,
          ratio= cty / hwy * 100)
```

새로운 변수를 생성할 때, 기존 변수와 관련된 수치, 논리, 문자열 연산을 수행할 수 있습니다. 다음처럼 제조사와 모델을 하나로 합쳐서 새로운 변수를 만들수도 있고, 배기량이 3 이상인지 여부를 나타내는 변수도 만들 수 있습니다.


```{R}
mutate(hyundai_2008_displ, newName=paste(manufacturer, model, sep="-"), dis3=displ >= 3)
```

다음 함수가 새로운 변수를 만들 때 자주 사용됩니다.

- row_number(), 각 행의 행번호, 각 행에 일련번호를 붙일 때 유용
- lead(), 기존 변수를 한 행, 또는 여러 행 빠르게 시작하는 변수
- lag(), 기존 변수를 한 행, 또는 여러 행 늦게 시작하는 변수
- cumsum()/cummean(), 누적 합과 평균
- min_rank(), 가장 작은 것부터 차례대로 크기 순서로 등수를 매기는 함수, desc() 함수를 변수에 적용한 후 등수를 매기면 가장 큰 것부터 순서를 매길 수 있음
- dense_rank(), percent_rank(), cume_dist(), ntile() 등

```{R}
store <- data.frame(month=1:6, sales=c(23, 45, 34, 67, 30, 41))
store
mutate(store,
       before = lag(sales, n = 1),   # 1 달 전 판매량  
       after = lead(sales, n = 1),   # 1 달 후 판매량  
       total = cumsum(sales),        # 누적 판매량
       mean = cummean(sales),        # 누적 평균 판매량
       rank1 = min_rank(sales),   # 판매량 순위 (올림차순)
       rank2 = min_rank(desc(sales))   # 판매량 순위 (내림차순)
       )
mutate(hyundai_2008_displ, id = row_number())
```

### summarize, 데이터 전체 또는 특정 열을 하나의 통계량으로 요약

summarize 함수는 데이터프레임을 하나의 행으로 요약합니다. 하나의 행으로 요약하기 위하여 변수의 모든 값을 하나의 값으로 통계요약하는 함수를 주로 이용하는데, 대표적인 통계요약 함수는 다음과 같습니다.

- n(), 행의 수
- sum(), 수치 변수의 합
- mean(), 수치 변수의 균
- median(), 수치 변수의 중위수
- sd(), 수치 변수의 표준편차
- var(), 수치 변수의 분산
- min(), 수치 변수의 최소값
- max(), 수치 변수의 최대값
- quantile(변수, probs), 수치 변수의probs` 분위수

```{R}
summarize(hyundai_2008_displ, 
          count=n(), 
          mean=mean(cty), 
          med=median(cty), 
          min=min(cty), 
          max=max(cty))
summarize(hyundai_2008_displ, 
          meanCty=mean(cty), 
          meanHwy=mean(hwy),
          medianCty=median(cty), 
          medianHqy=median(hwy))
```

across 함수는 select 처럼 열을 선택하여 동일한 함수를 적용할 수 있습니다. across 함수는 두 개의 주요 인수를 가지고 있는데, 첫 번째 인수는 `.cols`로 함수를 적용할 열을 지정하며, 두 번재 인수는 .fns로 열에 적용할 함수를 지정합니다.

```{R}
summarize(hyundai_2008_displ, across(c(cty, hwy), mean))
summarize(hyundai_2008_displ, across(c(cty, hwy), list(mean=mean, med=median)))
summarize(hyundai_2008_displ, across(c(cty, hwy), list(mean=mean, med=median), .names="{.fn}-{.col}"))
summarize(hyundai_2008_displ, across(c(cty, hwy), mean, .names="mean-{.col}"), 
                              across(c(cty, hwy), median, .names="med-{.col}"))
summarize(hyundai_2008_displ, across(where(is.numeric), sd))
```

### group_by(), 데이터 요약에만 사용되는 것은 아니나, 그룹별로 데이터를 통계 요약할 때 자주 사용

```{R}
byModel <- group_by(hyundai_2008_displ, model)
summarize(byModel, count=n(), mean=mean(cty), sd=sd(cty))
byModel <- group_by(hyundai_2008_displ, model, cty)
summarize(byModel, count=n(), mean=mean(cty))
```

group_by 는 summarize 와 함께 자주 사용되지만, mutate()나 filter() 등의 다른 dplyr 함수와 함께 사용될 수 있습니다.

```{R}
mutate(hyundai_2008_displ, rank=min_rank(desc(hwy)))  # 전체 데이터에서 고속도로 연비 순위 매기기
mutate(byModel, rank=min_rank(desc(hwy)))  # 모델 별로 고속도로 연비 순위 매기기
```

앞의 예에서 모델 별로 데이터 개수만을 세려면 다음과 같은 명령어를 사용하면 됩니다.
```{R}
byModel <- group_by(hyundai_2008_displ, model)
summarise(byModel, n=n())
count(hyundai_2008_displ, model)
count(mpg, class)
count(mpg, class, sort=TRUE)
count(mpg, class, cyl, sort=T)
```
### `%>%` 연산자

mpg 데이터에서 조사 연도와 모델 별로 데이터 수와 도심 연비의 평균을 구한 후, 평균이 22 이상인 모델로 이루어진 행을 추출하려고 합니다. 이를 수행하려면 다음처럼 변수를 이용하여 결과를 차례로 전달하거나, 함수를 결합하여 한 문장에 사용해야 합니다.

```{R}
# 1. 중간 결과를 요구
byModel <- group_by(mpg, model, year)
meanCty <- summarize(byModel, count=n(), mean=mean(cty))
filter(meanCty, mean >= 22)

# 2. 결과가 예상이 되지 않음
filter(summarize(group_by(mpg, model, year), count=n(), mean=mean(cty)), mean >= 22)
```

파이프 연산자(`%>%`)는 데이터 변환이 여러 단계를 거칠 때 불필요한 변수의 생성 없이도 함수 간에 중간 데이터를 전달할 수 있게 해 줍니다. 파이프 연산자는 함수의 결과를 뒷 함수의 첫 번째 인수로 전달해 줍니다. 파이프 연산자를 사용할 때는 그러므로 첫 번째 인수는 생략하여 기술합니다. 파이프 연산자로는 `magrittr` 패키지가 제공하는 `%>%` 연산자를 사용할 수도 있고, R 4.1.0 버전부터 도입된 기본 기능에 포함된 |> 연산자를 사용할 수도 있다. 

```{R}
mpg |> group_by(model, year) |> 
  summarize(count=n(), mean=mean(cty), .groups = 'keep') |>
  filter(mean >= 22)
```